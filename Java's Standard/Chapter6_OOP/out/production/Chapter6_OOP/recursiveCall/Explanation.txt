메서드 내부에서 메서드 자신을 다시 호출하는 것을 재귀 호출이라고 하며, 재귀호출을 하는 메서드를 제귀 매서드라고 한다.

void method() {
    method();   // 메서드 자신을 호출하는 재귀호출
}

호출된 메서드는 '값에 의한 호출(call by value)'을 통해, 원래의 값이 아닌 복사된 값으로 작업하기 때문에 호출한 메서드와
관계없이 독립적인 작업수행이 가능하다. 그런데 일방적인 재귀호출만 있다면 무한 루프가 되기 때문에 무한 반복문이 조건문과
함께 사용되는 것처럼, 재귀호출도 조건문이 필수적으로 수반된다.

***반복문은 그저 같은 문장을 반복해서 수행하는 것이지만, 메서드를 호출하는 재귀호출은 반복문보다 몇 가지 과정, 예를 들면
매개변수 복사와 종료 후 복귀할 주소저장 등.. 여러가지를 추가로 필요하기 때문에 반복문보다 수행시간이 더 길다.

그럼에도 사용하는 이유는 재귀호출이 주는 논리적 간결함 때문이다. 아무리 효율적이라도 알아보기 힘들게 작성하는 반복문과
다소 비효율적이더라도 알아보기 쉽게 코드를 작성하는 두 가지의 차이이다.

대표적인 재귀호출의 예시는 팩토리얼이다. f(n) = n * f(n-1), 단f(1) = 1 => FactorialTest.java
위 예제에서 Factorial메서드는 static메서드이므로 인스턴스를 생성하지 않고 직접 호출할 수 있다. 또한 mai()와 같은 클래스
에 있기 때문에 static메서드를 호출할 때 클래스이름을 생력하는 것이 가능하다. 따라서 FactorialTest.Factorial() 대신
Factorial()로 바로 호출할 수 있다. (https://mygumi.tistory.com/253)


-FactorialTest2.java
기존의 FactorialTest.java에서는 치명적인 결함이 존재한다. 인자가 0보다 작거나, 인자가 과도하게 클 경우에는 스택(재귀 호
출이 한번 반복될 때마다 1스택 추가)의 저장한계를 넘게 되고(혹은 무한 루프가 되어서), 스택오버플로우 에러가 발생한다.
따라서 언제나 메서드를 작성할 때 사용자가 적절한 값을 인자로 주겠지라는 믿음을 갖는 것이 아니라, 어떤 결과가 들어와도
에러 없이 코드가 실행될 수있도록 '매개 변수의 유효성 검사가 필요하다'
무한 호출은 메서드가 종료되지 않고 호출스택이 계속해서 쌓이게 되므로 호출스택의 메모리 한계를 넘어 스택오버플로우 발생

-PowerTest.java