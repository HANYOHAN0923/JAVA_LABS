- 생성자란?
생성자는 인스턴스가 생성될 때 호출되는 '인스턴스 초기화 메서드'이다.  """"따라서 인스턴스 변수의 초기화 작업에 주로 사용된다."""
또한 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용된다. (인스턴스 초기화 = 인스턴스 변수들의 초기화)

생성자 역시 메서드처럼 클래스 내에 선언되며, 구조도 메서드와 유사하지만 리턴값이 없다는 점이 다르다. void 함수와는 다른
것이다.

- 생성자의 조건
1) 생성자의 이름은 클래스의 이름과 같아야 한다.
2) 생성자는 리턴 값이 없다. (생성자도 메서드이기 때문에 리턴값이 없다는 의미의 void가 있어야 하지만, 모든 생성자가
리턴값이 없다는 공통점이 있기 때문에 void를 생략한다)

생성자는 오버로딩이 가능하므로 하나의 클래스에 여러개의 생성자가 존재할 수 있다.

class Card {
    Card() {
        // 매개 변수가 없는 생성자
    }

    Card(String k, int num) {
        // 매개 변수가 있는 생성자
    }
}

*** 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다. 생성자는 특별한 특징들이 있는
하나의 메서드라고 생각해야한다.


Card c = new Card();
1) 연산자 new에 의해서 메모리(heap)에 Card클래스의 인스턴스가 생성된다
2) 생성자 Card()가 호출되어 수행된다
3) 연산자 new의 결과로, 생성된 Card인스턴스의 주소가 반환되어 참조변수 c에 저장된다
지금까지 인스턴스를 생성하기위해 사용해왔던 className()이 바로 생성자였던 것이다. 인스턴스를 생성할 때는 반드시 클래스
내에 정의된 생성자 중의 하나를 선택하여 지정해주어야한다.


- 기본 생성자 (DefaultConstructor.java)
앞서 설명한 것에 있어서는 생성자를 모르고 코딩했지만, 사실상 모든 클래스에는 반드시 하나 이상의 생성자가 정의되어 있다.
그렇지만 앞선 모든 예제에서 생성자를 정의하지 않고도, 인스턴스를 생성할 수 있던 이유는 컴파일러가 기본 생성자를 제공하기
때문이다 => 컴파일러가 자동적으로 추가해주는 기본 생성자는 이와 같이 매개 변수도 없고 아무런 내용도 없는 생성자이다.
따라서 인스턴스 초기화 작업이 필요하지 않다면, 생성자를 굳이 정의하지 않고 기본 생성자를 사용하는 것이 좋다
(클래스의 접근 제어자가 public인 경우에는 기본 생성자로 public className() {}이 추가된다)생

기본 생성자가 컴파일러에 의해서 추가되는 경우는 클래스에 정의된 생성자가 하나도 없을 때 뿐이다.


- 매개변수가 있는 생성자(ParameterConstructor.java)


- 생성자에서 다른 생성자 호출하기(ThisEx.java)
같은 클래스의 멤버들 같에 서로 호출할 수 있는 것처럼 생성자 간에도 특정 조건 안에서 서로 호출이 가능하다.
- 생성자의 이름으로 클래스이름 대신 this를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.

생성자 Iphone()에서 또 다른 생성자 Iphone(String color, int version)을 호출하였다. 이처럼 생성자간의 호출에서는 생성자의
이름 대신 this를 사용해야하므로 Iphone대신 this를 사용하였다. 그리고 Iphone()의 첫째 줄에서 호출하였다라는 점을 기억하자

Iphone() {
    color = "Starlight";
    version = 13
}
Iphone() {
    this("Starlight",13);
}

위 2개의 코드는 같은 일을 하지만 오른쪽의 코드는 생성자 Iphone(String color, int version)을 활용해서 더 간략히한 것이다.
Iphone i1 = new Iphone();과 같이 생성자 Iphone()을 사용해서 Iphone인스턴스를 생성한 경우에, 인스턴스 변수 color는 Starlight
, version은 13으로 초기화 되도록하였다.

this.: 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어 있다. 모든 인스턴스 메서드에 지역변수로 숨겨진 채
존재한다.
this(),this() 매개변수: 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용한다.




??? 인스턴스가 그냥 조건 없이 생겼을 때 기본 값을 정하는 것이라고 볼 수 잇는 것인가?
인스턴스 매개변수를 초기화 값을 따로 지정하지 않으면 Default 값 int 0, dobule 0.0, String null 이렇게 초기화 된다.

(Car.java)
생성자 오버로딩: 메소드와 마찬가지로 매개변수의 개수와 타입이 다르다면 여러개의 생성자를 선언할 수 있다.
생성자를 여러개 정의할 수 있으니까, 기본 생성자 또한 내가 정의할 수 있는 것이다.
https://lowelllll.github.io/java/2018/12/09/java-this-차이점/
내 지식인의 질문 그대로 프린트 하면서 결과 도출해서 정리해보기 (변수 출력)
위 생성자는 아래와 같은 형태입니다. 그런데 아래 형태는 중복의 문장이 존재합니다.

// 생성자1

Iphone() {

this.color = "Starlight";

this.version = 31;

}

​

Iphone(String color) {

this.color = color;

this.version = 31;

}

​

Iphone(String color, int version) {

this.color = color;

this.version = version;

}

그래서 하나의 생성자(생성자 3)에 구체적인 구현을 하고, 나머지 생성자에서는 구현된 생성자를 호출하는 형태이지요.
생성자에서 필요한 작업은 하나의 생성자에 다 정의를 해두고,
나머지 생성자에서는 위 생성자를 호출해서 사용을 하는 것이지요.~


​

자바에서는 생성자를 호출할때 lphone("Starlight", 13); 이렇게 호출이 불가능 합니다.

​

생성자에서 자신의 생성자를 호출할 때에는 클래스명이 아니라 this를 붙이게 됩니다.

​

lphone("Starlight", 13); 이 호출문은 this("Starlight", 13); 이렇게 사용해야 하는것이지요.

​

2. 이 두가지의 차이점은 무엇일까요?

두번째 질문은 위에서 답변 되었지요? 중복을 없애기 위해 한곳에서 구체적인 코드를 만들고,

나머지 생성자에서는 그 부분을 호출하여 사용하는 형태입니다.

​

3. // 생성자1의 용도는 그냥 인스턴스를 생성할 때, 인스턴스 변수의 기본 값을 미리 초기화 해두는 것하고 같은 개념 아닌가요?

​

생성자1의 경우 기본값이라고 생각하시면 됩니다.

매개변수로 값이 주어지지 않았을때에는 위와 같이 값을 넣겠다고 이해하시면 됩니다.

​

4. this()에서의 this는 클래스 이름과 같고, this.color = color에서 this.color는 Iphone클래스의 인스턴스 변수를, = 뒤의 color는 생성자에서 받는 매개 변수 color를 가리키는 것이 맞나요?

​

this()는 자신의 생성자를 호출할때 사용하는 키워드이고,

this 라는것은 자신의 객체를 참조하는 참조변수 입니다.

​

this.color = color 여기에서 color라는 변수는 2가지가 존재합니다.

하나는 매개변수에서 선언된 color의 지역변수와 또하나는 멤버변수로 선언된 color변수이지요.

이렇게 변수명이 중복되면 어떤 변수인지 구분이 되지 않기 때문에 구분을 하기 위해 this를 사용합니다.

​

변수명이 중복되었을때 그냥 사용하게 되면 지역변수를 우선 사용하게 됩니다.

따라서 color라고 하면, 매개변수인 지역변수 color를 의미하고, 멤버변수를 사용하기 위해

this.color이라고 합니다.

참조변수로 객체의 멤버변수에 접근할때 참조변수.color 로 하듯이, this에는 현재 자신의 객체를 가리키므로

this.color이라고 하면 현재 객체의 멤버변수를 의미합니다.

​

따라서 멤버변수 color 에 매개변수로 넘어온 color값을 저장하는 것이지요.

​

5. 1번 질문에서 제가 이해한 것이 맞고, 2번에서 차이점이 없으면 굳이 this()를 사용하는 이유가 궁금합니다.

이 문제 답변도 위에서 이미 해결되었을겁니다.

​



- 생성자를 이용한 인스턴스 복사 (InstanceCopy.java)
***P456 Object클래스에 정의된 clone메서드를 이용하면 간단히 인스턴스를 복사할 수 있다.
인스턴스 c2는 c1을 복사하여 생성된 것이므로 서로 같은 상태를 갖지만, 서로 독립으로 메모리공간에 존재하는 별도의 인스턴스
이므로 c1의 값들이 변경되어도 c2는 영향을 받지 않는다

2번 생성자를 아래와 같이 기존의 코드(다른 생성자)를 호출하는 것이 바람직하다
Car (Car c) {
    this(c.color, c.gearType, c.door);
}