.class 위치 \bin
.java 위치 \src

pakage 만들기 (pakage 이름은 소문자로 시작)

ctrl + n -> class 검색 (class 이름은 대문자로 시작)
Which method stubs would you like to creat?
*public static void main(String[] args)
*Inherited abstract methods
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

제3강 변수
	정수형	문자형	실수형	논리형
1바이트	byte			boolean
2바이트	short	char		
4바이트	int		float	
8바이트	long		double	


정수 자료형

자료형	바이트 크기	수의 범위
byte	1		-2의 7승 ~ 2의 7승 -1
short	2		15승
int	4		31승
long	8		63승

int로 10을 표현할 때
0(부호 비트 양수 음수)0000000000000000000000000001010 (총 32비트)

***자료형 선언할 때 비트수를 넘어가면 에러가 발생

byte : 정수를 다루기 보다는 동영상, 음악 파일 등 실행 파일의 자료를 처리 할 때 사용하기 좋은 자료형
short: C언어와 호환시 주로 사용




문자 자료형
char은 하나의 문자만 저장 가능하다
자바에서는 문자를 2바이트로 처리
인코딩 - 각 문자에 따른 특정한 숫자 값(코드 값)을 부여
디코딩 - 숫자 값을 원래의 문자로 변환

A <=> 65 

문자세트 :  문자를 위한 코드 값(숫자 값)들을 정해 놓은 세트
ASCII : 1 바이트로 영문자,숫자,특수문자 등을 표현함
Unicode : 한국어, 중국어 복잡한 언어를 표현하기 위한 표준 인코딩 UTF-8, UTF-16이 대표적 (JAVA는 UTF-16사용)




실수 자료형
부동 소수점 방식: 실수를 지수부와 가수부로 표현함(무한의 실수를 표현하기 위한 방식)
0.1을 표현하는 방식: 1.0(가수) X(곱하기) 10(밑수)의-1일승(지수) [밑수는 주로 2, 10, 16을 사용한다]

float(4비트) : 부호 1비트, 지수부  8비트, 가부수 23비트
double(8비트) : 부호비트 1비트, 지수부 11비트, 가수부 52비트




논리 자료형
boolean으로 선언 - true, false 값 존재




자료형 없이 변수 사용하기(JAVA 10부터 지원)

***java의 변수는 변수의 자료형이 한번 정해지면 스크립트언어(Javascript, Python)같이 자료형 형태가 바뀔 수 없음!

자료형이 필요한 이유: 변수를 선언 할 때는 변수가 사용할 메모리 크기와 타입을 구분하기 위해 자료형을 사용

지역 변수 자료형 추론(var: 변수에 대입되는 값을 보고 컴파일러가 추론(지역변수로만 사용가능 / 맴버변수에서 사용 불가능))

var num = 10; -> int num = 10;
var dNum = 10.0; -> double dNum = 10.0;
var str = "hello"; -> String str = "hello";

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
제 4 강 상수(final) 값이 절대로 안 바뀜

상수 변수는 통상적으로 대문자로만 이름을 작성



리터럴(literal) : 프로그램에서 사용하는 모든 숫자, 값, 논리 값
final int MAX_NUM(상수) = 100(리터럴);
리터럴에 해당되는 값은 특정 메모리 공간인 상수 풀(constant pool)에 있음, 따라서 필요한 경우 상수 풀에서 가져와서 사용

변수가 선언되는 과정
리터럴 -> 프로그래밍 로딩 -> 상수 풀에 저장 -> 대입 / 복사 -> 변수로써 사용



형 변환(type conversion)
묵시적 형변환(ImplicitConversion): 작은 수에서 큰 수로(적은 바이트를 쓰는 수에서 더 큰 바이트를 쓰는 수로), 덜 정밀한 수(정수)에서 더 정밀한 수(실수)로 대입되는 경우 [즉 적은 메모리에서 큰 메모리로의 변환은 자연스럽게 가능하다 ]

byte(1byte) -> short(2byte) -> int(4byte) -> long(8byte) --묵시적--> float(4byte) -> double(8byte) 여기서 char 문자가 포함되는이유는 유니코드 참조
	       char (2byte) -> 

명시적 형변환(Explicit Conversion): 묵시적 형변환의 반대의 경우 [변환 되는 자료 형을 명시해야함, 자료의 손실로 인한 오류 발생]
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
제 5 강 항과 연산자
항: 연산에 사용되는 값
연산자: 항을 이용하여 연산하는 기호

연산자			설명		연산 예시
단향 연산자		항이 1개		++num
이항 연산자		항이 2개		num1 + num2;
삼항 연산자(조건 연산자)	항이 3개		(5>3)? 1:0;

대입 연산자
변수에 값을 대신 하는 연산자(절대로 같다라는 의미가 아니다) / 우선 순위가 가장 낮은 연산자

증가 연산자
++num 먼저 num 값이 1 증가한 후 val 변수에 대입
num++ val 변수에 기존 num 값을 먼저 대입한 후 num 값 1 증가
감소 연산자
--num 먼저 num 값이 1 감소한 후 val 변수에 대입
num-- val 변수에 기존 num 값을 먼저 대입한 후 num 값 1 감소

논리 연산자
&&(논리 곱) and
||(논리 합) or
!(부정) 단항 연산자, 참인 경우는 거짓으로 바꾸고, 거짓인 경우는 참으로 바꿉니다.

복합대입연산자
+= -= *= %= /=
<<= 
>>=
>>>=
&=
|=
^=